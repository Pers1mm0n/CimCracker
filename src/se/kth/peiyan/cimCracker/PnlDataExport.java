package se.kth.peiyan.cimCracker;

import java.awt.BorderLayout;
import java.awt.Color;
import java.awt.Component;
import java.awt.Font;
import java.awt.Insets;
import java.awt.event.ItemEvent;
import java.awt.event.ItemListener;
import java.awt.event.MouseEvent;
import java.util.EventObject;
import java.util.Vector;
import javax.swing.AbstractCellEditor;
import javax.swing.JCheckBox;
import javax.swing.JLabel;
import javax.swing.JOptionPane;
import javax.swing.JPanel;
import javax.swing.JTree;
import javax.swing.UIManager;
import javax.swing.event.TreeModelEvent;
import javax.swing.event.TreeModelListener;
import javax.swing.tree.DefaultMutableTreeNode;
import javax.swing.tree.DefaultTreeCellRenderer;
import javax.swing.tree.DefaultTreeModel;
import javax.swing.tree.TreeCellEditor;
import javax.swing.tree.TreeCellRenderer;
import javax.swing.tree.TreePath;

/**
 * the panel for displaying the every possible selections and asking user to 
 * choose which data need be exported into database.
 * <p>
 * Thanks to John Zukowski for the <a
 * href="http://www.java2s.com/Code/Java/Swing-JFC/CheckBoxNodeTreeSample.htm"
 * >sample code</a> upon which this is based.
 * </p>
 * 
 * @author peiyanli
 * @version 0.1, May 16, 2015
 */
public class PnlDataExport extends javax.swing.JPanel
{
    private DefaultMutableTreeNode root;
    private ColumnPath columnPath;
    private DataAnalyzer analyzer;
    private MainFrame parentFrame;
    /**
     * Creates new form DataExport
     */
    public PnlDataExport(StringVector cimObjectNames, Vector<Vector<String>> cimObjects, DataAnalyzer analyzer, MainFrame parentFrame)
    {
        this.columnPath = new ColumnPath();
        this.analyzer = analyzer;
        this.parentFrame = parentFrame;
        prepareTreeNode(cimObjectNames, cimObjects);
        
        initComponents();
    }
    
    private void prepareTreeNode(
            StringVector cimObjectNames,
            Vector<Vector<String>> cimObjects)
    {
        root = new DefaultMutableTreeNode("Root");
        
        for (int j = 0; j < cimObjectNames.size(); j++)
        {
            final DefaultMutableTreeNode treeNode = new DefaultMutableTreeNode(cimObjectNames.get(j));
            
            for (int i = 0; i < cimObjects.get(j).size(); i++)
            {
                treeAdd(treeNode, cimObjects.get(j).get(i), false);
            }
            root.add(treeNode);
        }
        
        final DefaultTreeModel treeModel = new DefaultTreeModel(root);
        tree = new JTree(treeModel);
        
        final CheckBoxNodeRenderer renderer = new CheckBoxNodeRenderer();
	tree.setCellRenderer(renderer);
        
        final CheckBoxNodeEditor editor = new CheckBoxNodeEditor(tree);
	tree.setCellEditor(editor);
	tree.setEditable(true);
        
        treeModel.addTreeModelListener(new TreeModelListener() // anonymous calss to handle node changing event
        {

            @Override
            public void treeNodesChanged(TreeModelEvent e)
            {
                TreePath[] paths = tree.getSelectionPaths();
		String[] selectedCoumnPath = new String[] {paths[0].getPathComponent(1).toString(), ((CheckBoxNodeData) (((DefaultMutableTreeNode) (paths[0].getPathComponent(2))).getUserObject())).getText()};
		if (!columnPath.contains(selectedCoumnPath))
		columnPath.add(selectedCoumnPath);
		else
		{
                    int index = columnPath.getIndex(selectedCoumnPath);
                    columnPath.remove(index);
		}
            }

            @Override
            public void treeNodesInserted(TreeModelEvent e)
            {
                // DO NOTHING
            }

            @Override
            public void treeNodesRemoved(TreeModelEvent e)
            {
                // DO NOTHING
            }

            @Override
            public void treeStructureChanged(TreeModelEvent e)
            {
                // DO NOTHING
            }
        });
    }
    
    private static DefaultMutableTreeNode treeAdd(
            final DefaultMutableTreeNode parent, final String text,
            final boolean checked)
    {
        final CheckBoxNodeData data = new CheckBoxNodeData(text, checked);
        final DefaultMutableTreeNode node = new DefaultMutableTreeNode(data);
	parent.add(node);
	return node;
    }

    /**
     * This method is called from within the constructor to initialize the form.
     * WARNING: Do NOT modify this code. The content of this method is always
     * regenerated by the Form Editor.
     */
    @SuppressWarnings("unchecked")
    // <editor-fold defaultstate="collapsed" desc="Generated Code">//GEN-BEGIN:initComponents
    private void initComponents()
    {

        buttonGroup = new javax.swing.ButtonGroup();
        javax.swing.JLabel lblDescription = new javax.swing.JLabel();
        rdbtnMyISAM = new javax.swing.JRadioButton();
        rdbtnInnoDB = new javax.swing.JRadioButton();
        javax.swing.JLabel lblStorageEngine = new javax.swing.JLabel();
        javax.swing.JScrollPane jScrollPane = new javax.swing.JScrollPane();
        tree = tree;
        btnOK = new javax.swing.JButton();

        lblDescription.setText("Choose the elements need be exported");

        buttonGroup.add(rdbtnMyISAM);
        rdbtnMyISAM.setSelected(true);
        rdbtnMyISAM.setText("MyISAM");

        buttonGroup.add(rdbtnInnoDB);
        rdbtnInnoDB.setText("InnoDB (only InnoDB supports Foreign Key, which isn't standard SQL)");
        rdbtnInnoDB.setEnabled(false);

        lblStorageEngine.setText("Choose the storage engine");

        jScrollPane.setViewportView(tree);

        btnOK.setText("OK");
        btnOK.addActionListener(new java.awt.event.ActionListener()
        {
            public void actionPerformed(java.awt.event.ActionEvent evt)
            {
                btnOKActionPerformed(evt);
            }
        });

        javax.swing.GroupLayout layout = new javax.swing.GroupLayout(this);
        this.setLayout(layout);
        layout.setHorizontalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                            .addComponent(lblDescription)
                            .addComponent(lblStorageEngine))
                        .addGap(0, 0, Short.MAX_VALUE))
                    .addGroup(layout.createSequentialGroup()
                        .addGap(10, 10, 10)
                        .addComponent(rdbtnMyISAM)
                        .addGap(10, 10, 10)
                        .addComponent(rdbtnInnoDB)
                        .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED, javax.swing.GroupLayout.DEFAULT_SIZE, Short.MAX_VALUE)
                        .addComponent(btnOK))
                    .addComponent(jScrollPane)))
        );
        layout.setVerticalGroup(
            layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
            .addGroup(layout.createSequentialGroup()
                .addContainerGap()
                .addComponent(lblDescription)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addComponent(jScrollPane, javax.swing.GroupLayout.DEFAULT_SIZE, 286, Short.MAX_VALUE)
                .addPreferredGap(javax.swing.LayoutStyle.ComponentPlacement.RELATED)
                .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.LEADING)
                    .addGroup(layout.createSequentialGroup()
                        .addComponent(lblStorageEngine)
                        .addGap(0, 0, 0)
                        .addGroup(layout.createParallelGroup(javax.swing.GroupLayout.Alignment.BASELINE)
                            .addComponent(rdbtnMyISAM)
                            .addComponent(rdbtnInnoDB)))
                    .addComponent(btnOK, javax.swing.GroupLayout.Alignment.TRAILING))
                .addContainerGap())
        );
    }// </editor-fold>//GEN-END:initComponents

    private void btnOKActionPerformed(java.awt.event.ActionEvent evt)//GEN-FIRST:event_btnOKActionPerformed
    {//GEN-HEADEREND:event_btnOKActionPerformed
        // TODO add your handling code here:
        analyzer.createTables(columnPath,rdbtnInnoDB.isSelected());
        JOptionPane.showMessageDialog(rdbtnInnoDB, "Database Updated", null, JOptionPane.INFORMATION_MESSAGE);
        parentFrame.setPocessLabel("Data exported");
    }//GEN-LAST:event_btnOKActionPerformed


    // Variables declaration - do not modify//GEN-BEGIN:variables
    private javax.swing.JButton btnOK;
    private javax.swing.ButtonGroup buttonGroup;
    private javax.swing.JRadioButton rdbtnInnoDB;
    private javax.swing.JRadioButton rdbtnMyISAM;
    private javax.swing.JTree tree;
    // End of variables declaration//GEN-END:variables
}

/**
 * data structure for the leaf in JTree, so that user can choose specific leaf
 * 
 */
class CheckBoxNodeData {

	private String text;
	private boolean checked;

	public CheckBoxNodeData(final String text, final boolean checked) {
		this.text = text;
		this.checked = checked;
	}

	public boolean isChecked() {
		return checked;
	}

	public void setChecked(final boolean checked) {
		this.checked = checked;
	}

	public String getText() {
		return text;
	}

	public void setText(final String text) {
		this.text = text;
	}

	@Override
	public String toString() {
		return /*getClass().getName() + */"[" + text + "/" + checked + "]";
	}
}

class CheckBoxNodeEditor extends AbstractCellEditor implements TreeCellEditor
{

	private final CheckBoxNodeRenderer renderer = new CheckBoxNodeRenderer();

	private final JTree theTree;

	public CheckBoxNodeEditor(final JTree tree) {
		theTree = tree;
	}

	@Override
	public Object getCellEditorValue() {
		final CheckBoxNodePanel panel = renderer.getPanel();
		final CheckBoxNodeData checkBoxNode =
			new CheckBoxNodeData(panel.label.getText(), panel.check.isSelected());
		return checkBoxNode;
	}

	@Override
	public boolean isCellEditable(final EventObject event) {
		if (!(event instanceof MouseEvent)) return false;
		final MouseEvent mouseEvent = (MouseEvent) event;

		final TreePath path =
			theTree.getPathForLocation(mouseEvent.getX(), mouseEvent.getY());
		if (path == null) return false;

		final Object node = path.getLastPathComponent();
		if (!(node instanceof DefaultMutableTreeNode)) return false;
		final DefaultMutableTreeNode treeNode = (DefaultMutableTreeNode) node;

		final Object userObject = treeNode.getUserObject();
		return userObject instanceof CheckBoxNodeData;
	}

	@Override
	public Component getTreeCellEditorComponent(final JTree tree,
		final Object value, final boolean selected, final boolean expanded,
		final boolean leaf, final int row)
	{

		final Component editor =
			renderer.getTreeCellRendererComponent(tree, value, true, expanded, leaf,
				row, true);

		// editor always selected / focused
		final ItemListener itemListener = new ItemListener() {

			@Override
			public void itemStateChanged(final ItemEvent itemEvent) {
				if (stopCellEditing()) {
					fireEditingStopped();
				}
			}
		};
		if (editor instanceof CheckBoxNodePanel) {
			final CheckBoxNodePanel panel = (CheckBoxNodePanel) editor;
			panel.check.addItemListener(itemListener);
		}

		return editor;
	}
}

/**
 * the checkBox at leaf
 */
class CheckBoxNodePanel extends JPanel {

	public final JLabel label = new JLabel();
	public final JCheckBox check = new JCheckBox();

	public CheckBoxNodePanel() {
		this.check.setMargin(new Insets(0, 0, 0, 0));
		setLayout(new BorderLayout());
		add(check, BorderLayout.WEST);
		add(label, BorderLayout.CENTER);
	}

}
/**
 * specify how to render the tree structure
 */
class CheckBoxNodeRenderer implements TreeCellRenderer {

	private final CheckBoxNodePanel panel = new CheckBoxNodePanel();

	private final DefaultTreeCellRenderer defaultRenderer =
		new DefaultTreeCellRenderer();

	private final Color selectionForeground, selectionBackground;
	private final Color textForeground, textBackground;

	protected CheckBoxNodePanel getPanel() {
		return panel;
	}

	public CheckBoxNodeRenderer() {
		final Font fontValue = UIManager.getFont("Tree.font");
		if (fontValue != null) panel.label.setFont(fontValue);

		final Boolean focusPainted =
			(Boolean) UIManager.get("Tree.drawsFocusBorderAroundIcon");
		panel.check.setFocusPainted(focusPainted != null && focusPainted);

		selectionForeground = UIManager.getColor("Tree.selectionForeground");
		selectionBackground = UIManager.getColor("Tree.selectionBackground");
		textForeground = UIManager.getColor("Tree.textForeground");
		textBackground = UIManager.getColor("Tree.textBackground");
	}

	// -- TreeCellRenderer methods --

	@Override
	public Component getTreeCellRendererComponent(final JTree tree,
		final Object value, final boolean selected, final boolean expanded,
		final boolean leaf, final int row, final boolean hasFocus)
	{
		CheckBoxNodeData data = null;
		if (value instanceof DefaultMutableTreeNode) {
			final DefaultMutableTreeNode node = (DefaultMutableTreeNode) value;
			final Object userObject = node.getUserObject();
			if (userObject instanceof CheckBoxNodeData) {
				data = (CheckBoxNodeData) userObject;
			}
		}

		final String stringValue =
			tree.convertValueToText(value, selected, expanded, leaf, row, false);
		panel.label.setText(stringValue);
		panel.check.setSelected(false);

		panel.setEnabled(tree.isEnabled());

		if (selected) {
			panel.setForeground(selectionForeground);
			panel.setBackground(selectionBackground);
			panel.label.setForeground(selectionForeground);
			panel.label.setBackground(selectionBackground);
		}
		else {
			panel.setForeground(textForeground);
			panel.setBackground(textBackground);
			panel.label.setForeground(textForeground);
			panel.label.setBackground(textBackground);
		}

		if (data == null) {
			// not a check box node; return default cell renderer
			return defaultRenderer.getTreeCellRendererComponent(tree, value,
				selected, expanded, leaf, row, hasFocus);
		}

		panel.label.setText(data.getText());
		panel.check.setSelected(data.isChecked());

		return panel;
	}

}